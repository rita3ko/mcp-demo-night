<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP vs Codemode</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Marked.js for Markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
            mono: ['JetBrains Mono', 'monospace'],
          },
          colors: {
            border: '#27272a',
            background: '#09090b',
            foreground: '#fafafa',
            muted: '#18181b',
            'muted-foreground': '#a1a1aa',
          }
        }
      }
    }
  </script>
  
  <style>
    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: #09090b;
      color: #fafafa;
    }
    
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #27272a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #3f3f46; }
    
    /* Markdown content styles */
    .markdown-content {
      line-height: 1.6;
    }
    .markdown-content p {
      margin-bottom: 0.75rem;
    }
    .markdown-content p:last-child {
      margin-bottom: 0;
    }
    .markdown-content strong {
      font-weight: 600;
      color: #fafafa;
    }
    .markdown-content em {
      font-style: italic;
    }
    .markdown-content ul, .markdown-content ol {
      margin: 0.5rem 0;
      padding-left: 1.25rem;
    }
    .markdown-content ul {
      list-style-type: disc;
    }
    .markdown-content ol {
      list-style-type: decimal;
    }
    .markdown-content li {
      margin: 0.25rem 0;
    }
    .markdown-content code {
      background: rgba(0, 0, 0, 0.3);
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85em;
    }
    .markdown-content pre {
      background: rgba(0, 0, 0, 0.3);
      padding: 0.75rem;
      border-radius: 0.375rem;
      overflow-x: auto;
      margin: 0.5rem 0;
    }
    .markdown-content pre code {
      background: none;
      padding: 0;
    }
    .markdown-content h1, .markdown-content h2, .markdown-content h3 {
      font-weight: 600;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }
    .markdown-content h1 { font-size: 1.25rem; }
    .markdown-content h2 { font-size: 1.125rem; }
    .markdown-content h3 { font-size: 1rem; }
    .markdown-content a {
      color: #60a5fa;
      text-decoration: underline;
    }
    .markdown-content blockquote {
      border-left: 2px solid #3f3f46;
      padding-left: 0.75rem;
      margin: 0.5rem 0;
      color: #a1a1aa;
    }
  </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">
  
  <!-- Header -->
  <header class="flex-shrink-0 border-b border-border px-6 py-4">
    <div class="flex items-center justify-between">
      <div>
        <h1 class="text-lg font-semibold">MCP vs Codemode</h1>
        <p class="text-sm text-muted-foreground">Compare AI agent approaches</p>
      </div>
      <button onclick="endSession()" class="px-3 py-1.5 text-sm bg-zinc-800 hover:bg-zinc-700 rounded-md transition-colors">
        End Session
      </button>
    </div>
  </header>
  
  <!-- Main Content -->
  <div class="flex-1 flex min-h-0">
    
    <!-- MCP Panel -->
    <div class="w-1/2 flex flex-col border-r border-border min-w-0">
      <div class="flex-shrink-0 px-4 py-3 border-b border-border">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <h2 class="text-sm font-medium">MCP Agent</h2>
            <span class="text-xs px-2 py-0.5 rounded-full bg-green-500/10 text-green-400">Traditional</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="mcp-status-dot" class="h-2 w-2 rounded-full bg-zinc-500"></span>
            <span id="mcp-status-text" class="text-xs text-muted-foreground">Connecting...</span>
          </div>
        </div>
        <p class="text-xs text-muted-foreground mt-1">Calls tools directly via MCP protocol</p>
      </div>
      <div id="mcp-messages" class="flex-1 overflow-y-auto p-4 space-y-3 min-w-0"></div>
    </div>
    
    <!-- Codemode Panel -->
    <div class="w-1/2 flex flex-col min-w-0">
      <div class="flex-shrink-0 px-4 py-3 border-b border-border">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <h2 class="text-sm font-medium">Codemode Agent</h2>
            <span class="text-xs px-2 py-0.5 rounded-full bg-orange-500/10 text-orange-400">Code-First</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="codemode-status-dot" class="h-2 w-2 rounded-full bg-zinc-500"></span>
            <span id="codemode-status-text" class="text-xs text-muted-foreground">Connecting...</span>
          </div>
        </div>
        <p class="text-xs text-muted-foreground mt-1">Generates and executes JavaScript code</p>
      </div>
      <div id="codemode-messages" class="flex-1 overflow-y-auto p-4 space-y-3 min-w-0"></div>
    </div>
  </div>
  
  <!-- Input Area -->
  <div class="flex-shrink-0 border-t border-border p-4">
    <div class="flex gap-3 max-w-4xl mx-auto">
      <input 
        type="text" 
        id="user-input" 
        placeholder="Ask both agents something..." 
        class="flex-1 px-4 py-2 bg-zinc-900 border border-border rounded-lg text-sm focus:outline-none focus:ring-1 focus:ring-zinc-600"
        onkeypress="if(event.key === 'Enter') sendMessage()"
      >
      <button onclick="sendMessage()" class="px-4 py-2 bg-white text-black font-medium rounded-lg text-sm hover:bg-zinc-200 transition-colors">
        Send
      </button>
    </div>
  </div>
  
  <!-- Session Summary Modal -->
  <div id="session-summary" class="hidden fixed inset-0 bg-black/80 items-center justify-center z-50">
    <div class="bg-zinc-900 border border-border rounded-xl p-6 max-w-md w-full mx-4">
      <h3 class="text-lg font-semibold mb-4">Session Summary</h3>
      <div class="space-y-4 mb-6">
        <div class="p-3 bg-zinc-800 rounded-lg">
          <div class="flex justify-between items-center">
            <span class="text-sm text-green-400">MCP Agent</span>
            <span id="mcp-tokens" class="text-sm font-mono">0 tokens</span>
          </div>
          <div class="flex justify-between text-xs text-muted-foreground mt-1">
            <span>Input: <span id="mcp-input">0</span></span>
            <span>Output: <span id="mcp-output">0</span></span>
          </div>
        </div>
        <div class="p-3 bg-zinc-800 rounded-lg">
          <div class="flex justify-between items-center">
            <span class="text-sm text-orange-400">Codemode Agent</span>
            <span id="codemode-tokens" class="text-sm font-mono">0 tokens</span>
          </div>
          <div class="flex justify-between text-xs text-muted-foreground mt-1">
            <span>Input: <span id="codemode-input">0</span></span>
            <span>Output: <span id="codemode-output">0</span></span>
          </div>
        </div>
        <div class="pt-2 border-t border-border">
          <p class="text-sm text-muted-foreground">More Efficient:</p>
          <p id="winner" class="text-base font-semibold mt-1">-</p>
        </div>
      </div>
      <div class="flex gap-3">
        <button onclick="closeSummary()" class="flex-1 px-4 py-2 bg-zinc-800 hover:bg-zinc-700 rounded-lg text-sm transition-colors">
          Close
        </button>
        <button onclick="newSession()" class="flex-1 px-4 py-2 bg-white text-black font-medium rounded-lg text-sm hover:bg-zinc-200 transition-colors">
          New Session
        </button>
      </div>
    </div>
  </div>

  <script>
    const SESSION_ID = 'session-v6';
    
    let mcpWs = null;
    let codemodeWs = null;
    
    const mcpMessages = document.getElementById('mcp-messages');
    const codemodeMessages = document.getElementById('codemode-messages');
    
    // Streaming state
    const streaming = {
      mcp: { element: null, content: '' },
      codemode: { element: null, content: '' }
    };
    
    // Update connection status
    function updateStatus(agent, connected) {
      const dot = document.getElementById(`${agent}-status-dot`);
      const text = document.getElementById(`${agent}-status-text`);
      if (connected) {
        dot.className = 'h-2 w-2 rounded-full bg-green-500';
        text.textContent = 'Connected';
      } else {
        dot.className = 'h-2 w-2 rounded-full bg-zinc-500';
        text.textContent = 'Disconnected';
      }
    }
    
    // Connect to agents
    function connectAgents() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      
      // MCP Agent
      mcpWs = new WebSocket(`${protocol}//${window.location.host}/agents/mcp-chat-agent/${SESSION_ID}`);
      mcpWs.onopen = () => updateStatus('mcp', true);
      mcpWs.onclose = () => updateStatus('mcp', false);
      mcpWs.onmessage = (e) => handleMessage('mcp', JSON.parse(e.data));
      
      // Codemode Agent
      codemodeWs = new WebSocket(`${protocol}//${window.location.host}/agents/codemode-chat-agent/${SESSION_ID}`);
      codemodeWs.onopen = () => updateStatus('codemode', true);
      codemodeWs.onclose = () => updateStatus('codemode', false);
      codemodeWs.onmessage = (e) => handleMessage('codemode', JSON.parse(e.data));
    }
    
    // Handle incoming messages
    function handleMessage(agent, data) {
      const container = agent === 'mcp' ? mcpMessages : codemodeMessages;
      const state = streaming[agent];
      
      if (data.type === 'cf_agent_use_chat_response' && data.body) {
        try {
          const event = JSON.parse(data.body);
          
          switch (event.type) {
            case 'text-start':
              state.element = createAssistantMessage(agent);
              state.content = '';
              container.appendChild(state.element);
              break;
              
            case 'text-delta':
              if (!state.element) {
                state.element = createAssistantMessage(agent);
                state.content = '';
                container.appendChild(state.element);
              }
              state.content += event.delta || '';
              const contentEl = state.element.querySelector('.message-content');
              if (contentEl) {
                // Render markdown as we stream
                contentEl.innerHTML = renderMarkdown(state.content);
              }
              container.scrollTop = container.scrollHeight;
              break;
              
            case 'text-end':
              // Final render of markdown when stream ends
              if (state.element && state.content) {
                const finalContentEl = state.element.querySelector('.message-content');
                if (finalContentEl) {
                  finalContentEl.innerHTML = renderMarkdown(state.content);
                }
              }
              state.element = null;
              state.content = '';
              break;
              
            case 'tool-input-start':
              addToolCall(container, event.toolName, null, agent);
              break;
              
            case 'tool-input-available':
              addToolCall(container, event.toolName, event.input, agent);
              break;
              
            case 'tool-output-available':
              addToolResult(container, event.output, agent);
              break;
          }
        } catch (e) {}
      }
    }
    
    // Create assistant message element
    function createAssistantMessage(agent) {
      const div = document.createElement('div');
      const color = agent === 'mcp' ? 'border-green-500/30' : 'border-orange-500/30';
      div.className = `p-3 rounded-lg bg-zinc-900 border-l-2 ${color}`;
      div.innerHTML = '<div class="message-content text-sm markdown-content"></div>';
      return div;
    }
    
    // Render markdown content
    function renderMarkdown(text) {
      if (typeof marked !== 'undefined') {
        // Configure marked for safe rendering
        marked.setOptions({
          breaks: true,  // Convert \n to <br>
          gfm: true,     // GitHub Flavored Markdown
        });
        return marked.parse(text);
      }
      // Fallback to escaped text if marked isn't loaded
      return escapeHtml(text);
    }
    
    // Add user message
    function addUserMessage(container, text) {
      const div = document.createElement('div');
      div.className = 'p-3 rounded-lg bg-zinc-800 ml-8';
      div.innerHTML = `<div class="text-sm">${escapeHtml(text)}</div>`;
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }
    
    // Add tool call
    function addToolCall(container, toolName, input, agent) {
      // Skip if no input yet (tool-input-start without data)
      if (!input) return;
      
      const div = document.createElement('div');
      const color = agent === 'mcp' ? 'text-green-400' : 'text-orange-400';
      div.className = 'p-3 rounded-lg bg-zinc-900/50 border border-border';
      div.innerHTML = `
        <div class="text-xs ${color} font-medium mb-2">Tool: ${escapeHtml(toolName || 'unknown')}</div>
        <pre class="text-xs font-mono text-muted-foreground overflow-x-auto">${escapeHtml(JSON.stringify(input, null, 2))}</pre>
      `;
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }
    
    // Generate a friendly summary from codemode result
    function generateSummary(result) {
      if (typeof result === 'string') {
        // Try to parse embedded JSON in the result string
        const jsonMatch = result.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          try {
            const data = JSON.parse(jsonMatch[0]);
            return generateSummaryFromData(data, result);
          } catch (e) {}
        }
        // Return first line as summary
        return result.split('\n')[0];
      }
      return generateSummaryFromData(result, '');
    }
    
    function generateSummaryFromData(data, originalText) {
      // Event created
      if (data.title && data.date && data.id) {
        const date = new Date(data.date);
        const dateStr = date.toLocaleDateString('en-US', { 
          weekday: 'long', 
          month: 'long', 
          day: 'numeric',
          year: 'numeric',
          hour: 'numeric',
          minute: '2-digit'
        });
        const location = data.location ? ` at ${data.location}` : '';
        if (originalText.includes('created')) {
          return `Event "${data.title}" created for ${dateStr}${location}`;
        } else if (originalText.includes('updated')) {
          return `Event "${data.title}" updated - ${dateStr}${location}`;
        } else if (originalText.includes('deleted')) {
          return `Event "${data.title}" has been deleted`;
        }
        return `Event: ${data.title} - ${dateStr}${location}`;
      }
      
      // Profile
      if (data.first_name && data.last_name && data.email) {
        return `Profile: ${data.first_name} ${data.last_name} (${data.email})`;
      }
      
      // RSVP
      if (data.status && data.event_id) {
        return `RSVP status: ${data.status}`;
      }
      
      // List of events
      if (Array.isArray(data) && data.length > 0 && data[0].title) {
        return `Found ${data.length} event${data.length > 1 ? 's' : ''}`;
      }
      
      // Fallback
      return originalText.split('\n')[0] || 'Operation completed';
    }
    
    // Add tool result
    function addToolResult(container, output, agent) {
      const div = document.createElement('div');
      
      // Try to parse output
      let parsed = null;
      if (typeof output === 'string') {
        try {
          parsed = JSON.parse(output);
        } catch (e) {}
      } else if (typeof output === 'object') {
        parsed = output;
      }
      
      if (parsed && parsed.code && parsed.result !== undefined) {
        // Codemode result with code - show collapsible details only (LLM provides the prose response)
        div.className = 'space-y-2';
        div.innerHTML = `
          <details class="p-3 rounded-lg bg-zinc-900/50 border border-border">
            <summary class="text-xs text-orange-400 font-medium cursor-pointer">View Generated Code & Details</summary>
            <div class="mt-3 space-y-3">
              <div>
                <div class="text-xs text-muted-foreground mb-1">Code</div>
                <pre class="text-xs font-mono bg-black/30 p-2 rounded overflow-x-auto">${escapeHtml(parsed.code)}</pre>
              </div>
              <div>
                <div class="text-xs text-muted-foreground mb-1">Raw Result</div>
                <pre class="text-xs font-mono bg-black/30 p-2 rounded overflow-x-auto">${escapeHtml(typeof parsed.result === 'string' ? parsed.result : JSON.stringify(parsed.result, null, 2))}</pre>
              </div>
            </div>
          </details>
        `;
      } else {
        // Regular tool result (MCP)
        const color = agent === 'mcp' ? 'text-green-400' : 'text-orange-400';
        const displayText = typeof output === 'string' ? output : JSON.stringify(output, null, 2);
        div.className = 'p-3 rounded-lg bg-zinc-900/50 border border-border';
        div.innerHTML = `
          <div class="text-xs ${color} font-medium mb-2">Result</div>
          <pre class="text-xs font-mono text-muted-foreground overflow-x-auto">${escapeHtml(displayText)}</pre>
        `;
      }
      
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }
    
    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Message history for each agent
    let mcpChatMessages = [];
    let codemodeChatMessages = [];
    
    // Send message to both agents
    function sendMessage() {
      const input = document.getElementById('user-input');
      const message = input.value.trim();
      if (!message) return;
      
      // Reset streaming state
      streaming.mcp = { element: null, content: '' };
      streaming.codemode = { element: null, content: '' };
      
      // Add user message to both panels
      addUserMessage(mcpMessages, message);
      addUserMessage(codemodeMessages, message);
      
      // Add to message history
      const userMessage = { id: crypto.randomUUID(), role: 'user', content: message };
      mcpChatMessages.push({...userMessage, id: crypto.randomUUID()});
      codemodeChatMessages.push({...userMessage, id: crypto.randomUUID()});
      
      // Create payload in format AIChatAgent expects
      const createPayload = (messages) => JSON.stringify({
        type: 'cf_agent_use_chat_request',
        id: crypto.randomUUID(),
        init: {
          method: 'POST',
          body: JSON.stringify({ messages })
        }
      });
      
      if (mcpWs?.readyState === WebSocket.OPEN) {
        mcpWs.send(createPayload(mcpChatMessages));
      }
      if (codemodeWs?.readyState === WebSocket.OPEN) {
        codemodeWs.send(createPayload(codemodeChatMessages));
      }
      
      input.value = '';
    }
    
    // End session - show summary
    async function endSession() {
      try {
        const res = await fetch('/api/usage');
        const usage = await res.json();
        
        // MCP tokens
        const mcpInput = usage.mcp?.inputTokens || 0;
        const mcpOutput = usage.mcp?.outputTokens || 0;
        const mcpTotal = mcpInput + mcpOutput;
        
        // Codemode tokens - only count Claude, not GPT-4 codegen
        const codemodeInput = usage.codemode?.claude?.inputTokens || 0;
        const codemodeOutput = usage.codemode?.claude?.outputTokens || 0;
        const codemodeTotal = codemodeInput + codemodeOutput;
        
        // Update UI
        document.getElementById('mcp-tokens').textContent = `${mcpTotal.toLocaleString()} tokens`;
        document.getElementById('mcp-input').textContent = mcpInput.toLocaleString();
        document.getElementById('mcp-output').textContent = mcpOutput.toLocaleString();
        
        document.getElementById('codemode-tokens').textContent = `${codemodeTotal.toLocaleString()} tokens`;
        document.getElementById('codemode-input').textContent = codemodeInput.toLocaleString();
        document.getElementById('codemode-output').textContent = codemodeOutput.toLocaleString();
        
        const winner = document.getElementById('winner');
        if (mcpTotal === 0 && codemodeTotal === 0) {
          winner.textContent = 'No messages sent yet';
          winner.className = 'text-base font-semibold text-muted-foreground mt-1';
        } else if (mcpTotal === codemodeTotal) {
          winner.textContent = "It's a tie!";
          winner.className = 'text-base font-semibold text-muted-foreground mt-1';
        } else if (mcpTotal < codemodeTotal) {
          const pct = ((codemodeTotal - mcpTotal) / codemodeTotal * 100).toFixed(0);
          winner.textContent = `MCP Agent (${pct}% fewer tokens)`;
          winner.className = 'text-base font-semibold text-green-400 mt-1';
        } else {
          const pct = ((mcpTotal - codemodeTotal) / mcpTotal * 100).toFixed(0);
          winner.textContent = `Codemode Agent (${pct}% fewer tokens)`;
          winner.className = 'text-base font-semibold text-orange-400 mt-1';
        }
      } catch (e) {
        console.error('Failed to fetch usage:', e);
      }
      
      document.getElementById('session-summary').classList.remove('hidden');
      document.getElementById('session-summary').classList.add('flex');
    }
    
    // Close summary modal
    function closeSummary() {
      document.getElementById('session-summary').classList.add('hidden');
      document.getElementById('session-summary').classList.remove('flex');
    }
    
    // Start new session
    async function newSession() {
      try {
        await fetch('/api/clear', { method: 'POST' });
        await fetch('/api/admin/reset-fluma', { method: 'POST' });
      } catch (e) {}
      
      // Reset local state
      mcpMessages.innerHTML = '';
      codemodeMessages.innerHTML = '';
      streaming.mcp = { element: null, content: '' };
      streaming.codemode = { element: null, content: '' };
      mcpChatMessages = [];
      codemodeChatMessages = [];
      
      closeSummary();
      
      // Reconnect
      if (mcpWs) mcpWs.close();
      if (codemodeWs) codemodeWs.close();
      setTimeout(connectAgents, 500);
    }
    
    // Initialize
    connectAgents();
  </script>
</body>
</html>
